package com.ian_cornelius.kplcmobi.utils.generators;

/*
Keep live track of consumption track, with notification being sent if critical.

Hook up when frag live, detach when frag inactive, constantly update vars after a given time period.

Test with sample data

Singleton cause runs in entire app cycle. Or just use static methods...no need to maintain an object ref...

Yes. Save heap from maintaining a sort of dead object, while batch job not done.

Batch update after every hour?

What if it extends application, so runs in the app's lifetime that way?

Maybe...

So, how does generation happen?

We get summary data for current account (switch acc btn at end of separator line)
TODO Put switch acc btn for consumption track at end of separator line

Use date format dd/mm/yy to save all date vars. Now, extract dd, and mm, get time period bought.

Add 30 days. Use monthly average (TODO Save average as monthly average)
Calculate consumption based on current date (system provided, server verified), using days passed since
last purchase. Do a batch hourly update, recalculating values, and updating on screen, or sending notif if not
in notifications frag

Set alarm on log-in/sign up, if just_logged_in/signed_up arg passed. On log out, cancel alarms

Register for UI, get live onScreen updates, deregister, get offline updates

Being a broadcast receiver, no longer a singleton. Class restructured. Need local persistence of auth status incase of reboot
Or can I access firebase here? Proly yes. Lemme give it a shot

WOOOOOORKED!!!

Now, this class only calculates consumed units, based on previous and consumption rate per hour - proly locally save
this var for later, to ease calculation load? No. C'mon. It's simple maths. Not even calculus. Save storage.
 */

import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.os.AsyncTask;
import android.util.Log;

import com.ian_cornelius.kplcmobi.models.ConsumptionTrackLastHistoryRecord;
import com.ian_cornelius.kplcmobi.utils.FirebaseUtils.FirebaseStaticReqManager;
import com.ian_cornelius.kplcmobi.utils.data_managers.ConsumptionTrackLocalStoreManager;
import com.ian_cornelius.kplcmobi.utils.data_managers.ConsumptionTrackManager;
import com.ian_cornelius.kplcmobi.utils.services.AlarmResetService;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;

public class ConsumptionTrackGenerator extends BroadcastReceiver {

    @Override
    public void onReceive (Context context, Intent intent){

        //Handle reboots while user still signed in
        if (intent.getAction() != null){

            if (intent.getAction().equals("android.intent.action.BOOT_COMPLETED")){


                //First, ensure we still have the signed in user. Firebase maintains local auth
                //status. Use classes I've defined for that...cause of reference error? Maybe not...
                //But just to be safe

                //Wait...alarm cancelled on log out. So this condition may never be...or what if data cleared?
                if (FirebaseStaticReqManager.getInstance().requestAuthCurrentUser(this) != null){

                    //Have a logged in user. Can reset my alarm to continue
                    Intent serviceIntent = new Intent(context, AlarmResetService.class);
                    context.startService(serviceIntent);
                }
            }


        } else {

            //Now do the maths/computations needed.
            //Use AsyncTask to have this BroadcastReceiver held in memory a bit longer, as required.
            final PendingResult pendingResult = goAsync();
            Task asyncTask = new Task(pendingResult, intent, context);
            asyncTask.execute();
        }

    }


    /*
    Task class to run AsyncTask
     */
    private static class Task extends AsyncTask<String, Integer, String>{

        /*
        Fake data. Actual data has to be read from file, generated by ConsumptionTrackManager,
        containing last date, monthly average and consumption rate per hour.

        Alternatively, if local persistence works well for firebase, use firebase data and sieve it here
        */
        private String lastDate; //= "30/5/2019 08:55"; //format dd/mm/yy hh:mm
        private float monthlyAverageUnits; //= 30;
        private float consumptionRatePerHour; //derived

        //Hold units bought and consumed
        private int prevUnitsBought; //= 30; //not a necessary var. Actually necessary. To infer remaining units
        private float consumedUnits; //derived

        private final PendingResult pendingResult;
        private final Intent intent;
        private final Context context;

        //constructor
        private Task(PendingResult pendingResult, Intent intent, Context context){

            this.pendingResult = pendingResult;
            this.intent = intent;
            this.context = context;
        }

        //Run calculations in background
        @Override
        protected String doInBackground(String... strings){

            //calculateCurrentConsumption();
            calculateConsumption();

            return strings.toString();
        }


        //Might need to fire a notification. Do that here. Might maintain in log file too notification fire status
        @Override
        protected void onPostExecute(String s){

//            super.onPostExecute(s);

            //Send values to consumption track manager. Will decide what to do

            ConsumptionTrackManager.getInstance().updateMetrics(prevUnitsBought, consumedUnits, context);
            //Must call finish to allow this class to be recycled
            pendingResult.finish();
        }


        /*
        Method to calculate current consumption

        Maths getting quite interesting. Since I have the monthly average, I know the consumption per day (its by
        30, duuuuh). So, what I need to do is to know how much time has elapsed since last purchase, and, show current
        estimated number of units. If frag attached, show on UI. Else, if not attached,
        fire notification. Test with 1 minute quotas

        WOOOOORKED BABY!!!!
         */
        private void calculateCurrentConsumption(){

            /*
            First, get rate per hour, if not provided
             */
            consumptionRatePerHour = monthlyAverageUnits /(30 * 24);
            Log.e("CONSUMPTION RATE", String.valueOf(consumptionRatePerHour));

            /*
            Knowing rate per hour, get time elapsed (in hours), and know total consumed
             */
            consumedUnits = consumptionRatePerHour*elapsedTimeHrs();
        }

        private void calculateConsumption(){

            /*
            NEW CODE
             */
            //get last history
            ConsumptionTrackLastHistoryRecord record = (ConsumptionTrackLastHistoryRecord) ConsumptionTrackLocalStoreManager.getInstance().readLocal(ConsumptionTrackLocalStoreManager.REQUEST_LAST_HISTORY, context);

            if (record.getPrevUnitsBought() == 0){

                //we have a problem. Set all vals to zero and return. Log at manager
                prevUnitsBought = 0;
                consumedUnits = 0;
                return;

            } else {

                //extract data
                prevUnitsBought = record.getPrevUnitsBought();
                monthlyAverageUnits = record.getMonthlyAverageUnits();
                lastDate = record.getLastDate();
            }

            //now get rate per hour
            consumptionRatePerHour = monthlyAverageUnits/(30*24);
            Log.e("CONSUMPTION RATE", String.valueOf(consumptionRatePerHour));

            /*
            Knowing rate per hour, get time elapsed (in hours), and know total consumed
             */
            consumedUnits = consumptionRatePerHour*elapsedTimeHrs();

        }


        //Calculate elapsed time (hrs)
        private long elapsedTimeHrs(){

            //Set our date format
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(ConsumptionTrackLocalStoreManager.LOCAL_DATE_FORMAT);

            //Hold our elapsedHrs
            long elapsedHrs = 0;

            //Parse
            try{

                Date dateLast = simpleDateFormat.parse(lastDate);
                Date dateCurrent = simpleDateFormat.parse(simpleDateFormat.format(Calendar.getInstance().getTime()));

                elapsedHrs = (dateCurrent.getTime() - dateLast.getTime())/(1000 * 60 * 60);
                Log.e("CURRENT DATE", String.valueOf(dateCurrent.getTime()));
                Log.e("RAW DIFF", String.valueOf(dateCurrent.getTime() - dateLast.getTime()));

            } catch (ParseException e){

                Log.e("Failed to parse", e.toString());
            }

            Log.e("ELAPSED HOURS",String.valueOf(elapsedHrs));
            return  elapsedHrs;

        }

//        //Get elapsed days
//        private int elapsedDays(){
//
//            SimpleDateFormat format = new SimpleDateFormat("dd/mm/yy");
//            int days = 1;
//            try{
//
//                Date dateLast = format.parse(lastDate);
//                Date dateCurrent = format.parse(format.format(Calendar.getInstance().getTime()));
//                days = (int) TimeUnit.DAYS.convert(dateCurrent.getTime() - dateLast.getTime(), TimeUnit.MILLISECONDS)
//
//            } catch (ParseException e){
//
//                Log.e("FAILED TO PARSE",e.toString());
//            }
//
//            //return days
//            return days;
//        }

    }

}
